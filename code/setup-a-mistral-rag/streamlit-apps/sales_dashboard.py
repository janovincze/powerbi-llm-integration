"""
Sales Analytics Dashboard
Generated by Snowflake Cortex - Runs natively in Streamlit in Snowflake

This dashboard provides real-time sales analytics with interactive filters,
KPI cards, and visualizations. All data stays within Snowflake's secure perimeter.
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta

# Page configuration
st.set_page_config(
    page_title="Sales Analytics Dashboard",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
    <style>
    .metric-card {
        background-color: #f0f2f6;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
    }
    .big-font {
        font-size: 24px !important;
        font-weight: bold;
    }
    </style>
""", unsafe_allow_html=True)


@st.cache_resource
def get_connection():
    """Initialize Snowflake connection."""
    return st.connection("snowflake")


@st.cache_data(ttl=300)  # Cache for 5 minutes
def load_data(_conn, start_date, end_date, regions, segments):
    """
    Load sales data with applied filters.

    Args:
        _conn: Snowflake connection (underscore prefix excludes from cache key)
        start_date: Filter start date
        end_date: Filter end date
        regions: List of selected regions
        segments: List of selected customer segments

    Returns:
        DataFrame with filtered sales data
    """
    # Build WHERE clause
    conditions = ["s.order_date BETWEEN %(start_date)s AND %(end_date)s"]

    if regions and "All" not in regions:
        regions_str = ", ".join([f"'{r}'" for r in regions])
        conditions.append(f"s.region IN ({regions_str})")

    if segments and "All" not in segments:
        segments_str = ", ".join([f"'{s}'" for s in segments])
        conditions.append(f"c.segment IN ({segments_str})")

    where_clause = " AND ".join(conditions)

    query = f"""
        SELECT
            s.order_id,
            s.order_date,
            s.customer_id,
            c.name as customer_name,
            c.segment,
            s.product_category,
            s.quantity,
            s.unit_price,
            s.quantity * s.unit_price as revenue,
            s.region
        FROM sales s
        LEFT JOIN customers c ON s.customer_id = c.customer_id
        WHERE {where_clause}
        ORDER BY s.order_date DESC
    """

    return _conn.query(query, params={"start_date": start_date, "end_date": end_date})


@st.cache_data(ttl=300)
def get_filter_options(_conn):
    """Get unique values for filter dropdowns."""
    regions = _conn.query("SELECT DISTINCT region FROM sales ORDER BY region")
    segments = _conn.query("SELECT DISTINCT segment FROM customers ORDER BY segment")
    return regions["REGION"].tolist(), segments["SEGMENT"].tolist()


@st.cache_data(ttl=300)
def calculate_kpis(_conn, start_date, end_date, prev_start_date, prev_end_date):
    """Calculate KPI values and their deltas."""
    query = """
        SELECT
            SUM(CASE WHEN order_date BETWEEN %(start_date)s AND %(end_date)s
                     THEN quantity * unit_price ELSE 0 END) as current_revenue,
            SUM(CASE WHEN order_date BETWEEN %(prev_start)s AND %(prev_end)s
                     THEN quantity * unit_price ELSE 0 END) as prev_revenue,
            COUNT(CASE WHEN order_date BETWEEN %(start_date)s AND %(end_date)s
                       THEN 1 END) as current_orders,
            COUNT(CASE WHEN order_date BETWEEN %(prev_start)s AND %(prev_end)s
                       THEN 1 END) as prev_orders,
            COUNT(DISTINCT CASE WHEN order_date BETWEEN %(start_date)s AND %(end_date)s
                                THEN customer_id END) as current_customers,
            COUNT(DISTINCT CASE WHEN order_date BETWEEN %(prev_start)s AND %(prev_end)s
                                THEN customer_id END) as prev_customers
        FROM sales
    """
    return _conn.query(query, params={
        "start_date": start_date,
        "end_date": end_date,
        "prev_start": prev_start_date,
        "prev_end": prev_end_date
    })


def format_currency(value):
    """Format number as currency."""
    if value >= 1_000_000:
        return f"${value/1_000_000:.1f}M"
    elif value >= 1_000:
        return f"${value/1_000:.1f}K"
    else:
        return f"${value:.2f}"


def format_number(value):
    """Format number with thousand separators."""
    return f"{value:,.0f}"


def calculate_delta(current, previous):
    """Calculate percentage change."""
    if previous == 0:
        return 0
    return ((current - previous) / previous) * 100


# Initialize connection
conn = get_connection()

# Sidebar filters
st.sidebar.title("ðŸ“Š Dashboard Filters")

# Get filter options
try:
    regions_list, segments_list = get_filter_options(conn)
    regions_list = ["All"] + regions_list
    segments_list = ["All"] + segments_list
except Exception as e:
    st.error(f"Error loading filter options: {e}")
    regions_list = ["All"]
    segments_list = ["All"]

# Date range filter
st.sidebar.subheader("Date Range")
col1, col2 = st.sidebar.columns(2)
default_end = datetime.now().date()
default_start = default_end - timedelta(days=30)

with col1:
    start_date = st.date_input("Start Date", default_start)
with col2:
    end_date = st.date_input("End Date", default_end)

# Calculate previous period for comparison
date_range_days = (end_date - start_date).days
prev_end_date = start_date - timedelta(days=1)
prev_start_date = prev_end_date - timedelta(days=date_range_days)

# Region filter
st.sidebar.subheader("Region")
selected_regions = st.sidebar.multiselect(
    "Select Regions",
    options=regions_list,
    default=["All"]
)

# Segment filter
st.sidebar.subheader("Customer Segment")
selected_segments = st.sidebar.multiselect(
    "Select Segments",
    options=segments_list,
    default=["All"]
)

# Refresh button
if st.sidebar.button("ðŸ”„ Refresh Data"):
    st.cache_data.clear()
    st.rerun()

# Main dashboard
st.title("ðŸ“ˆ Sales Analytics Dashboard")
st.markdown(f"*Data from {start_date} to {end_date}*")

# Load data
try:
    df = load_data(conn, start_date, end_date, selected_regions, selected_segments)
    kpis = calculate_kpis(conn, start_date, end_date, prev_start_date, prev_end_date)
except Exception as e:
    st.error(f"Error loading data: {e}")
    st.stop()

# KPI Row
st.subheader("Key Performance Indicators")
kpi_cols = st.columns(4)

# Total Revenue
with kpi_cols[0]:
    current_revenue = float(kpis["CURRENT_REVENUE"].iloc[0] or 0)
    prev_revenue = float(kpis["PREV_REVENUE"].iloc[0] or 0)
    delta = calculate_delta(current_revenue, prev_revenue)
    st.metric(
        label="Total Revenue",
        value=format_currency(current_revenue),
        delta=f"{delta:+.1f}%"
    )

# Order Count
with kpi_cols[1]:
    current_orders = int(kpis["CURRENT_ORDERS"].iloc[0] or 0)
    prev_orders = int(kpis["PREV_ORDERS"].iloc[0] or 0)
    delta = calculate_delta(current_orders, prev_orders)
    st.metric(
        label="Order Count",
        value=format_number(current_orders),
        delta=f"{delta:+.1f}%"
    )

# Average Order Value
with kpi_cols[2]:
    avg_order = current_revenue / current_orders if current_orders > 0 else 0
    prev_avg = prev_revenue / prev_orders if prev_orders > 0 else 0
    delta = calculate_delta(avg_order, prev_avg)
    st.metric(
        label="Avg Order Value",
        value=format_currency(avg_order),
        delta=f"{delta:+.1f}%"
    )

# Unique Customers
with kpi_cols[3]:
    current_customers = int(kpis["CURRENT_CUSTOMERS"].iloc[0] or 0)
    prev_customers = int(kpis["PREV_CUSTOMERS"].iloc[0] or 0)
    delta = calculate_delta(current_customers, prev_customers)
    st.metric(
        label="Unique Customers",
        value=format_number(current_customers),
        delta=f"{delta:+.1f}%"
    )

st.divider()

# Charts Row
chart_col1, chart_col2 = st.columns(2)

# Revenue Trend
with chart_col1:
    st.subheader("Revenue Trend")

    if not df.empty:
        daily_revenue = df.groupby("ORDER_DATE")["REVENUE"].sum().reset_index()
        daily_revenue.columns = ["Date", "Revenue"]

        fig = px.line(
            daily_revenue,
            x="Date",
            y="Revenue",
            title="",
            labels={"Revenue": "Revenue ($)", "Date": ""},
            color_discrete_sequence=["#0066CC"]
        )
        fig.update_layout(
            hovermode="x unified",
            showlegend=False,
            margin=dict(l=0, r=0, t=10, b=0)
        )
        fig.update_traces(
            hovertemplate="$%{y:,.0f}<extra></extra>"
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No data available for the selected filters")

# Revenue by Region
with chart_col2:
    st.subheader("Revenue by Region")

    if not df.empty:
        region_revenue = df.groupby("REGION")["REVENUE"].sum().reset_index()
        region_revenue.columns = ["Region", "Revenue"]
        region_revenue = region_revenue.sort_values("Revenue", ascending=True)

        fig = px.bar(
            region_revenue,
            x="Revenue",
            y="Region",
            orientation="h",
            title="",
            labels={"Revenue": "Revenue ($)", "Region": ""},
            color_discrete_sequence=["#00994D"]
        )
        fig.update_layout(
            margin=dict(l=0, r=0, t=10, b=0),
            showlegend=False
        )
        fig.update_traces(
            hovertemplate="%{y}: $%{x:,.0f}<extra></extra>"
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No data available for the selected filters")

st.divider()

# Second Charts Row
chart_col3, chart_col4 = st.columns(2)

# Revenue by Category
with chart_col3:
    st.subheader("Revenue by Product Category")

    if not df.empty:
        category_revenue = df.groupby("PRODUCT_CATEGORY")["REVENUE"].sum().reset_index()
        category_revenue.columns = ["Category", "Revenue"]

        fig = px.pie(
            category_revenue,
            values="Revenue",
            names="Category",
            title="",
            color_discrete_sequence=px.colors.qualitative.Set2
        )
        fig.update_layout(
            margin=dict(l=0, r=0, t=10, b=0),
            showlegend=True,
            legend=dict(orientation="h", yanchor="bottom", y=-0.2)
        )
        fig.update_traces(
            hovertemplate="%{label}: $%{value:,.0f} (%{percent})<extra></extra>"
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No data available for the selected filters")

# Customer Segment Distribution
with chart_col4:
    st.subheader("Revenue by Customer Segment")

    if not df.empty:
        segment_revenue = df.groupby("SEGMENT")["REVENUE"].sum().reset_index()
        segment_revenue.columns = ["Segment", "Revenue"]
        segment_revenue = segment_revenue.sort_values("Revenue", ascending=False)

        fig = px.bar(
            segment_revenue,
            x="Segment",
            y="Revenue",
            title="",
            labels={"Revenue": "Revenue ($)", "Segment": ""},
            color_discrete_sequence=["#FF6600"]
        )
        fig.update_layout(
            margin=dict(l=0, r=0, t=10, b=0),
            showlegend=False
        )
        fig.update_traces(
            hovertemplate="%{x}: $%{y:,.0f}<extra></extra>"
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No data available for the selected filters")

st.divider()

# Top Customers Table
st.subheader("Top 10 Customers by Revenue")

if not df.empty:
    top_customers = (
        df.groupby(["CUSTOMER_ID", "CUSTOMER_NAME", "SEGMENT"])
        .agg({
            "REVENUE": "sum",
            "ORDER_ID": "count"
        })
        .reset_index()
        .rename(columns={
            "CUSTOMER_NAME": "Customer",
            "SEGMENT": "Segment",
            "REVENUE": "Total Revenue",
            "ORDER_ID": "Order Count"
        })
        .sort_values("Total Revenue", ascending=False)
        .head(10)
    )

    # Format currency column
    top_customers["Total Revenue"] = top_customers["Total Revenue"].apply(
        lambda x: f"${x:,.2f}"
    )

    st.dataframe(
        top_customers[["Customer", "Segment", "Total Revenue", "Order Count"]],
        use_container_width=True,
        hide_index=True
    )

    # Download button
    csv = df.to_csv(index=False)
    st.download_button(
        label="ðŸ“¥ Download Full Data (CSV)",
        data=csv,
        file_name=f"sales_data_{start_date}_{end_date}.csv",
        mime="text/csv"
    )
else:
    st.info("No data available for the selected filters")

# Footer
st.divider()
st.caption(f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | Data source: Snowflake")
